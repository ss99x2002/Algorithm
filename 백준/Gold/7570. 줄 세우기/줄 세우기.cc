#include <iostream>
#include <algorithm>
#include <queue>
#include <cmath>
#include <unordered_map>
using namespace std;

// 모든 어린이들에게 입학할 때 주어진 번호고, 옷에 번호표 달고 있다.
// 선생님은 다음과 같은 방법으로 줄 세울거다.

// 1. 줄 서있는 어린이 중 한명을 선택해 제일 앞이나 뒤로 보낸다.
// 위 방법으로 빈자리 생길 경우, 빈 자리의 뒤에 있는 어린이가 한걸음씩
// 앞으로 와서 빈자리 메꾼다.

// ex) 5 2 4 1 3
// 1. 1번 제일 앞으로 보낸다. (1,5,2,4,3)
// 2. 4번 제일 뒤로 보낸다. (1,5,2,3,4)
// 3. 5번 제일 뒤로 보낸다. (1,2,3,4,5)

// 번호순서대로 줄을 세울 때, 앞이나 뒤로 보내는 어린이의 수 최솟값 찾기.

// n = 어린이 수,  어린이 번호 차례대로 입력

int n,num;
int  dp[1000001];
int maxLen =0;

// dp와 LIS (최대 증가 부분 수열)
// LIS -> dp로 풀었던 기억.

int main() {
    cin >> n;
    for (int i=1; i<=n; i++){
        cin >> num;
        dp[num] = dp[num-1] + 1;
        maxLen = max(maxLen, dp[num]); //만약에 입력 받은 값들이 연속되면
        // dp[num]은 계속 커지기 때문에, maxLen이랑 비교해서, 현재 값보다 큰 연속 길이를 찾음.
    }

    cout << n-maxLen << "\n"; //전체에서 즉 연속되지 않은 경우를 뺀 만큼, 이동이 필요하기 때문.
    // 궁금한 점.
    // 맨 뒤, 맨 앞으로만 보내는데 연속되지 않은 경우 만큼 뺀다고
    // Q. 바로 자기 위치에 찾아가는 경우가 보장되나??

    // A. x가 올바른 위치를 벗어났다면, 그 아이를 맨 앞으로 보내면 모든 왼쪽 번호 구간 앞에 붙고,
    // 맨 뒤로 보내면 모든 오른쪽 번호 구간 뒤에 붙어서. 즉시 올바른상대적 위치에 들어갈 수 있다.

    //입력: 5  2  4  1  3
    //pos: 1→4, 2→1, 3→5, 4→2, 5→3  (번호→원래 위치)
    return 0;
}